"""
ABOV3 Genesis - Vulnerability Scanner
Comprehensive vulnerability scanning and security assessment
"""

import asyncio
import json
import re
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Set
from enum import Enum


class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class VulnerabilityScanner:
    """Comprehensive vulnerability scanner for code and dependencies"""
    
    def __init__(self, project_path: Path, audit_logger=None):
        self.project_path = project_path
        self.audit_logger = audit_logger
        
        # Vulnerability patterns
        self.vulnerability_patterns = self._initialize_patterns()
        
        # Scan statistics
        self.scan_stats = {
            'total_scans': 0,
            'files_scanned': 0,
            'vulnerabilities_found': 0,
            'by_severity': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        }
    
    def _initialize_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize vulnerability detection patterns"""
        return {
            'python': [
                {
                    'pattern': r'eval\s*\(',
                    'severity': SeverityLevel.CRITICAL,
                    'cwe': 'CWE-95',
                    'description': 'Code injection via eval()'
                },
                {
                    'pattern': r'exec\s*\(',
                    'severity': SeverityLevel.CRITICAL,
                    'cwe': 'CWE-95',
                    'description': 'Code execution via exec()'
                },
                {
                    'pattern': r'os\.system\s*\(',
                    'severity': SeverityLevel.HIGH,
                    'cwe': 'CWE-78',
                    'description': 'OS command injection'
                },
                {
                    'pattern': r'subprocess\.call\s*\([^)]*shell\s*=\s*True',
                    'severity': SeverityLevel.HIGH,
                    'cwe': 'CWE-78',
                    'description': 'Shell command injection via subprocess'
                },
                {
                    'pattern': r'pickle\.loads?\s*\(',
                    'severity': SeverityLevel.HIGH,
                    'cwe': 'CWE-502',
                    'description': 'Insecure deserialization with pickle'
                }
            ],
            'javascript': [
                {
                    'pattern': r'\beval\s*\(',
                    'severity': SeverityLevel.CRITICAL,
                    'cwe': 'CWE-95',
                    'description': 'Code injection via eval()'
                },
                {
                    'pattern': r'innerHTML\s*=.*\+',
                    'severity': SeverityLevel.HIGH,
                    'cwe': 'CWE-79',
                    'description': 'XSS via innerHTML'
                },
                {
                    'pattern': r'document\.write\s*\(',
                    'severity': SeverityLevel.MEDIUM,
                    'cwe': 'CWE-79',
                    'description': 'XSS via document.write'
                }
            ],
            'sql': [
                {
                    'pattern': r'SELECT.*\+.*WHERE',
                    'severity': SeverityLevel.HIGH,
                    'cwe': 'CWE-89',
                    'description': 'SQL injection vulnerability'
                }
            ]
        }
    
    async def scan_project(self, scan_type: str = "full") -> Dict[str, Any]:
        """Scan project for vulnerabilities"""
        self.scan_stats['total_scans'] += 1
        
        try:
            results = {
                'scan_id': f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                'timestamp': datetime.now().isoformat(),
                'scan_type': scan_type,
                'project_path': str(self.project_path),
                'vulnerabilities': [],
                'summary': {
                    'total_files': 0,
                    'vulnerable_files': 0,
                    'total_vulnerabilities': 0,
                    'by_severity': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
                }
            }
            
            if scan_type in ["full", "code"]:
                code_results = await self._scan_code_vulnerabilities()
                results['vulnerabilities'].extend(code_results['vulnerabilities'])
                results['summary']['total_files'] += code_results['files_scanned']
            
            if scan_type in ["full", "dependencies"]:
                dep_results = await self._scan_dependencies()
                results['vulnerabilities'].extend(dep_results['vulnerabilities'])
            
            # Update summary
            vulnerable_files = set()
            for vuln in results['vulnerabilities']:
                if vuln.get('file_path'):
                    vulnerable_files.add(vuln['file_path'])
                results['summary']['by_severity'][vuln['severity'].lower()] += 1
            
            results['summary']['vulnerable_files'] = len(vulnerable_files)
            results['summary']['total_vulnerabilities'] = len(results['vulnerabilities'])
            
            # Update statistics
            self.scan_stats['vulnerabilities_found'] += results['summary']['total_vulnerabilities']
            for severity, count in results['summary']['by_severity'].items():
                self.scan_stats['by_severity'][severity] += count
            
            # Audit log
            if self.audit_logger:
                await self.audit_logger.log_event("vulnerability_scan_completed", {
                    "scan_id": results['scan_id'],
                    "scan_type": scan_type,
                    "vulnerabilities_found": results['summary']['total_vulnerabilities'],
                    "critical_vulnerabilities": results['summary']['by_severity']['critical']
                })
            
            return {'success': True, 'results': results}
            
        except Exception as e:
            return {'success': False, 'error': f'Vulnerability scan failed: {str(e)}'}
    
    async def _scan_code_vulnerabilities(self) -> Dict[str, Any]:
        """Scan source code for vulnerabilities"""
        vulnerabilities = []
        files_scanned = 0
        
        # File extensions to scan
        extensions = {'.py': 'python', '.js': 'javascript', '.jsx': 'javascript', 
                     '.ts': 'javascript', '.tsx': 'javascript', '.sql': 'sql'}
        
        for ext, lang in extensions.items():
            for file_path in self.project_path.rglob(f'*{ext}'):
                if file_path.is_file():
                    files_scanned += 1
                    file_vulns = await self._scan_file(file_path, lang)
                    vulnerabilities.extend(file_vulns)
        
        self.scan_stats['files_scanned'] += files_scanned
        
        return {
            'vulnerabilities': vulnerabilities,
            'files_scanned': files_scanned
        }
    
    async def _scan_file(self, file_path: Path, language: str) -> List[Dict[str, Any]]:
        """Scan individual file for vulnerabilities"""
        vulnerabilities = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            patterns = self.vulnerability_patterns.get(language, [])
            
            for line_num, line in enumerate(content.split('\n'), 1):
                for pattern_info in patterns:
                    if re.search(pattern_info['pattern'], line, re.IGNORECASE):
                        vulnerabilities.append({
                            'file_path': str(file_path.relative_to(self.project_path)),
                            'line_number': line_num,
                            'line_content': line.strip(),
                            'severity': pattern_info['severity'].value,
                            'cwe': pattern_info['cwe'],
                            'description': pattern_info['description'],
                            'pattern': pattern_info['pattern'],
                            'language': language
                        })
            
        except Exception as e:
            pass  # Skip files that can't be read
        
        return vulnerabilities
    
    async def _scan_dependencies(self) -> Dict[str, Any]:
        """Scan dependencies for known vulnerabilities"""
        vulnerabilities = []
        
        # Check for Python requirements
        req_files = ['requirements.txt', 'requirements-dev.txt', 'Pipfile']
        
        for req_file in req_files:
            req_path = self.project_path / req_file
            if req_path.exists():
                # This would integrate with vulnerability databases
                # For now, just flag outdated packages
                vulnerabilities.extend(await self._check_python_requirements(req_path))
        
        # Check for Node.js packages
        package_json = self.project_path / 'package.json'
        if package_json.exists():
            vulnerabilities.extend(await self._check_node_packages(package_json))
        
        return {'vulnerabilities': vulnerabilities}
    
    async def _check_python_requirements(self, req_file: Path) -> List[Dict[str, Any]]:
        """Check Python requirements for vulnerabilities"""
        vulnerabilities = []
        
        try:
            with open(req_file, 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if line and not line.startswith('#'):
                        # Simple check for potentially vulnerable packages
                        vulnerable_packages = {
                            'django': {'versions': ['<3.2'], 'cve': 'CVE-2021-33203'},
                            'flask': {'versions': ['<2.0'], 'cve': 'CVE-2021-23385'},
                            'requests': {'versions': ['<2.25.0'], 'cve': 'CVE-2020-26137'}
                        }
                        
                        for package, vuln_info in vulnerable_packages.items():
                            if package in line.lower():
                                vulnerabilities.append({
                                    'file_path': str(req_file.relative_to(self.project_path)),
                                    'line_number': line_num,
                                    'line_content': line,
                                    'severity': SeverityLevel.MEDIUM.value,
                                    'cwe': 'CWE-1104',
                                    'description': f'Potentially vulnerable {package} version',
                                    'cve': vuln_info['cve'],
                                    'type': 'dependency'
                                })
        
        except Exception:
            pass
        
        return vulnerabilities
    
    async def _check_node_packages(self, package_json: Path) -> List[Dict[str, Any]]:
        """Check Node.js packages for vulnerabilities"""
        vulnerabilities = []
        
        try:
            with open(package_json, 'r') as f:
                data = json.load(f)
            
            dependencies = {**data.get('dependencies', {}), **data.get('devDependencies', {})}
            
            # Check for known vulnerable packages
            vulnerable_packages = {
                'lodash': {'versions': ['<4.17.21'], 'cve': 'CVE-2021-23337'},
                'axios': {'versions': ['<0.21.1'], 'cve': 'CVE-2020-28168'}
            }
            
            for package, version in dependencies.items():
                if package in vulnerable_packages:
                    vulnerabilities.append({
                        'file_path': str(package_json.relative_to(self.project_path)),
                        'package': package,
                        'version': version,
                        'severity': SeverityLevel.MEDIUM.value,
                        'cwe': 'CWE-1104',
                        'description': f'Potentially vulnerable {package} version',
                        'cve': vulnerable_packages[package]['cve'],
                        'type': 'dependency'
                    })
        
        except Exception:
            pass
        
        return vulnerabilities
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get vulnerability scanner statistics"""
        return self.scan_stats.copy()