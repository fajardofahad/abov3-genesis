"""
ABOV3 Genesis - Code Generation Engine
Advanced multi-file code generation engine that creates production-ready implementations
"""

import asyncio
import os
import json
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from pathlib import Path
from datetime import datetime
import logging
import re

from ..core.processor import FeatureRequirement, TechnicalContext
from ..planning.engine import ImplementationPlan, TaskStep, Milestone

logger = logging.getLogger(__name__)


@dataclass
class CodeFile:
    """Represents a generated code file"""
    path: str
    content: str
    language: str
    file_type: str  # 'implementation', 'test', 'config', 'documentation'
    dependencies: List[str]
    imports: List[str]
    exports: List[str]
    metadata: Dict[str, Any]


@dataclass
class GenerationResult:
    """Result of code generation process"""
    success: bool
    files_created: List[CodeFile]
    files_modified: List[str]
    errors: List[str]
    warnings: List[str]
    metrics: Dict[str, Any]
    generation_time: float


class CodeGenerationEngine:
    """
    Advanced code generation engine that creates complete, production-ready 
    implementations from requirements and plans
    """
    
    def __init__(self, ollama_client=None, project_path: Optional[Path] = None):
        self.ollama_client = ollama_client
        self.project_path = Path(project_path) if project_path else Path.cwd()
        self.templates = self._initialize_templates()
        self.code_patterns = self._initialize_code_patterns()
        self.generation_strategies = self._initialize_generation_strategies()
        
    def _initialize_templates(self) -> Dict[str, Dict[str, str]]:
        """Initialize code templates for different frameworks and patterns"""
        return {
            'python': {
                'fastapi_main': '''"""
{description}
Generated by ABOV3 Genesis NL2Code Module
"""

from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
import uvicorn

from database import get_db, engine
from models import Base
from routes import {route_imports}

# Create database tables
Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="{project_name}",
    description="{description}",
    version="1.0.0"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
{router_includes}

@app.get("/")
async def root():
    return {{"message": "Welcome to {project_name} API"}}

@app.get("/health")
async def health_check():
    return {{"status": "healthy", "timestamp": "{timestamp}"}}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
''',
                'sqlalchemy_model': '''"""
{description}
Database models for {entity_name}
"""

from sqlalchemy import Column, Integer, String, DateTime, Boolean, ForeignKey, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime

Base = declarative_base()

class {model_name}(Base):
    __tablename__ = "{table_name}"
    
    id = Column(Integer, primary_key=True, index=True)
    {fields}
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<{model_name}(id={{self.id}}>"
    
    def to_dict(self):
        return {{
            "id": self.id,
            {to_dict_fields}
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }}
''',
                'fastapi_router': '''"""
{description}
API routes for {entity_name}
"""

from fastapi import APIRouter, HTTPException, Depends, status
from sqlalchemy.orm import Session
from typing import List, Optional

from database import get_db
from models.{model_file} import {model_name}
from schemas.{schema_file} import {schema_name}Create, {schema_name}Response, {schema_name}Update

router = APIRouter(prefix="/{endpoint_prefix}", tags=["{tag_name}"])

@router.get("/", response_model=List[{schema_name}Response])
async def get_{endpoint_prefix}(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db)
):
    """Get all {entity_name} with pagination"""
    items = db.query({model_name}).offset(skip).limit(limit).all()
    return items

@router.get("/{{item_id}}", response_model={schema_name}Response)
async def get_{entity_name}_by_id(item_id: int, db: Session = Depends(get_db)):
    """Get {entity_name} by ID"""
    item = db.query({model_name}).filter({model_name}.id == item_id).first()
    if not item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"{entity_name} with id {{item_id}} not found"
        )
    return item

@router.post("/", response_model={schema_name}Response, status_code=status.HTTP_201_CREATED)
async def create_{entity_name}(
    item_data: {schema_name}Create,
    db: Session = Depends(get_db)
):
    """Create new {entity_name}"""
    db_item = {model_name}(**item_data.dict())
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

@router.put("/{{item_id}}", response_model={schema_name}Response)
async def update_{entity_name}(
    item_id: int,
    item_data: {schema_name}Update,
    db: Session = Depends(get_db)
):
    """Update {entity_name} by ID"""
    item = db.query({model_name}).filter({model_name}.id == item_id).first()
    if not item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"{entity_name} with id {{item_id}} not found"
        )
    
    update_data = item_data.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(item, field, value)
    
    db.commit()
    db.refresh(item)
    return item

@router.delete("/{{item_id}}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_{entity_name}(item_id: int, db: Session = Depends(get_db)):
    """Delete {entity_name} by ID"""
    item = db.query({model_name}).filter({model_name}.id == item_id).first()
    if not item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"{entity_name} with id {{item_id}} not found"
        )
    
    db.delete(item)
    db.commit()
    return None
''',
                'pydantic_schema': '''"""
{description}
Pydantic schemas for {entity_name}
"""

from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional

class {schema_name}Base(BaseModel):
    {base_fields}

class {schema_name}Create({schema_name}Base):
    """Schema for creating {entity_name}"""
    pass

class {schema_name}Update({schema_name}Base):
    """Schema for updating {entity_name}"""
    {update_fields}

class {schema_name}Response({schema_name}Base):
    """Schema for {entity_name} response"""
    id: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        orm_mode = True
''',
                'database_config': '''"""
Database configuration and connection setup
"""

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os
from dotenv import load_dotenv

load_dotenv()

DATABASE_URL = os.getenv(
    "DATABASE_URL", 
    "sqlite:///./app.db"  # Default to SQLite for development
)

engine = create_engine(
    DATABASE_URL,
    connect_args={{"check_same_thread": False}} if "sqlite" in DATABASE_URL else {{}}
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    """Database dependency for FastAPI"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
''',
                'requirements_txt': '''# Core dependencies
fastapi==0.104.1
uvicorn[standard]==0.24.0
python-multipart==0.0.6
python-dotenv==1.0.0

# Database
sqlalchemy==2.0.23
alembic==1.12.1

# Authentication (if needed)
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6

# Testing
pytest==7.4.3
pytest-asyncio==0.21.1
httpx==0.25.2

# Development
black==23.11.0
isort==5.12.0
flake8==6.1.0
'''
            },
            'javascript': {
                'express_main': '''/**
 * {description}
 * Generated by ABOV3 Genesis NL2Code Module
 */

const express = require('express');
const cors = require('cors');
const morgan = require('morgan');
const helmet = require('helmet');
require('dotenv').config();

// Import routes
{route_imports}

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(morgan('combined'));
app.use(express.json());
app.use(express.urlencoded({{ extended: true }}));

// Routes
app.get('/', (req, res) => {{
    res.json({{ 
        message: 'Welcome to {project_name} API',
        version: '1.0.0',
        timestamp: new Date().toISOString()
    }});
}});

app.get('/health', (req, res) => {{
    res.json({{ 
        status: 'healthy',
        timestamp: new Date().toISOString()
    }});
}});

// API routes
{route_uses}

// Error handling middleware
app.use((err, req, res, next) => {{
    console.error(err.stack);
    res.status(500).json({{ 
        error: 'Something went wrong!',
        message: process.env.NODE_ENV === 'development' ? err.message : undefined
    }});
}});

// 404 handler
app.use('*', (req, res) => {{
    res.status(404).json({{ error: 'Route not found' }});
}});

app.listen(PORT, () => {{
    console.log(`ðŸš€ Server running on port ${{PORT}}`);
    console.log(`ðŸ“„ API documentation: http://localhost:${{PORT}}/`);
}});

module.exports = app;
''',
                'express_router': '''/**
 * {description}
 * API routes for {entity_name}
 */

const express = require('express');
const router = express.Router();
const {{ body, validationResult }} = require('express-validator');

// Mock data storage (replace with actual database)
let {entity_name_lower} = [];
let nextId = 1;

// Validation middleware
const validate{entity_name} = [
    {validations},
    (req, res, next) => {{
        const errors = validationResult(req);
        if (!errors.isEmpty()) {{
            return res.status(400).json({{ errors: errors.array() }});
        }}
        next();
    }}
];

// GET /{endpoint_prefix} - Get all items
router.get('/', async (req, res) => {{
    try {{
        const {{ skip = 0, limit = 100 }} = req.query;
        const items = {entity_name_lower}.slice(skip, skip + limit);
        res.json({{
            data: items,
            total: {entity_name_lower}.length,
            skip: parseInt(skip),
            limit: parseInt(limit)
        }});
    }} catch (error) {{
        res.status(500).json({{ error: error.message }});
    }}
}});

// GET /{endpoint_prefix}/:id - Get item by ID
router.get('/:id', async (req, res) => {{
    try {{
        const id = parseInt(req.params.id);
        const item = {entity_name_lower}.find(item => item.id === id);
        
        if (!item) {{
            return res.status(404).json({{ error: '{entity_name} not found' }});
        }}
        
        res.json(item);
    }} catch (error) {{
        res.status(500).json({{ error: error.message }});
    }}
}});

// POST /{endpoint_prefix} - Create new item
router.post('/', validate{entity_name}, async (req, res) => {{
    try {{
        const newItem = {{
            id: nextId++,
            ...req.body,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        }};
        
        {entity_name_lower}.push(newItem);
        res.status(201).json(newItem);
    }} catch (error) {{
        res.status(500).json({{ error: error.message }});
    }}
}});

// PUT /{endpoint_prefix}/:id - Update item
router.put('/:id', validate{entity_name}, async (req, res) => {{
    try {{
        const id = parseInt(req.params.id);
        const itemIndex = {entity_name_lower}.findIndex(item => item.id === id);
        
        if (itemIndex === -1) {{
            return res.status(404).json({{ error: '{entity_name} not found' }});
        }}
        
        {entity_name_lower}[itemIndex] = {{
            ...{entity_name_lower}[itemIndex],
            ...req.body,
            updatedAt: new Date().toISOString()
        }};
        
        res.json({entity_name_lower}[itemIndex]);
    }} catch (error) {{
        res.status(500).json({{ error: error.message }});
    }}
}});

// DELETE /{endpoint_prefix}/:id - Delete item
router.delete('/:id', async (req, res) => {{
    try {{
        const id = parseInt(req.params.id);
        const itemIndex = {entity_name_lower}.findIndex(item => item.id === id);
        
        if (itemIndex === -1) {{
            return res.status(404).json({{ error: '{entity_name} not found' }});
        }}
        
        {entity_name_lower}.splice(itemIndex, 1);
        res.status(204).send();
    }} catch (error) {{
        res.status(500).json({{ error: error.message }});
    }}
}});

module.exports = router;
''',
                'package_json': '''{
    "name": "{project_name_lower}",
    "version": "1.0.0",
    "description": "{description}",
    "main": "app.js",
    "scripts": {
        "start": "node app.js",
        "dev": "nodemon app.js",
        "test": "jest",
        "test:watch": "jest --watch",
        "lint": "eslint .",
        "lint:fix": "eslint . --fix"
    },
    "dependencies": {
        "express": "^4.18.2",
        "cors": "^2.8.5",
        "helmet": "^7.1.0",
        "morgan": "^1.10.0",
        "dotenv": "^16.3.1",
        "express-validator": "^7.0.1"
    },
    "devDependencies": {
        "nodemon": "^3.0.1",
        "jest": "^29.7.0",
        "supertest": "^6.3.3",
        "eslint": "^8.53.0"
    },
    "keywords": [
        "api",
        "express",
        "node"
    ],
    "author": "ABOV3 Genesis",
    "license": "MIT"
}'''
            },
            'react': {
                'app_component': '''/**
 * {description}
 * Main App component
 */

import React from 'react';
import {{ BrowserRouter as Router, Routes, Route }} from 'react-router-dom';
import {{ QueryClient, QueryClientProvider }} from '@tanstack/react-query';
import {{ Toaster }} from 'react-hot-toast';

// Components
import Navbar from './components/Navbar';
import Home from './pages/Home';
{route_imports}

// Styles
import './App.css';

const queryClient = new QueryClient();

function App() {{
    return (
        <QueryClientProvider client={{queryClient}}>
            <Router>
                <div className="App">
                    <Navbar />
                    <main className="main-content">
                        <Routes>
                            <Route path="/" element={{<Home />}} />
                            {routes}
                        </Routes>
                    </main>
                    <Toaster position="top-right" />
                </div>
            </Router>
        </QueryClientProvider>
    );
}}

export default App;
''',
                'component_template': '''/**
 * {description}
 * {component_name} component
 */

import React, {{ useState{additional_hooks} }} from 'react';
{imports}
import './{component_name}.css';

const {component_name} = ({{ {props} }}) => {{
    {state_definitions}

    {event_handlers}

    return (
        <div className="{component_name_lower}">
            {jsx_content}
        </div>
    );
}};

export default {component_name};
''',
                'package_json': '''{
    "name": "{project_name_lower}",
    "version": "1.0.0",
    "private": true,
    "dependencies": {
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.8.1",
        "@tanstack/react-query": "^5.8.4",
        "axios": "^1.6.2",
        "react-hot-toast": "^2.4.1"
    },
    "scripts": {
        "start": "react-scripts start",
        "build": "react-scripts build",
        "test": "react-scripts test",
        "eject": "react-scripts eject",
        "lint": "eslint src/",
        "lint:fix": "eslint src/ --fix"
    },
    "devDependencies": {
        "@testing-library/jest-dom": "^5.16.5",
        "@testing-library/react": "^13.4.0",
        "@testing-library/user-event": "^13.5.0",
        "react-scripts": "5.0.1"
    },
    "browserslist": {
        "production": [
            ">0.2%",
            "not dead",
            "not op_mini all"
        ],
        "development": [
            "last 1 chrome version",
            "last 1 firefox version",
            "last 1 safari version"
        ]
    }
}'''
            }
        }
    
    def _initialize_code_patterns(self) -> Dict[str, List[str]]:
        """Initialize code generation patterns"""
        return {
            'crud_operations': ['create', 'read', 'update', 'delete', 'list'],
            'auth_patterns': ['login', 'logout', 'register', 'verify', 'reset_password'],
            'api_patterns': ['get', 'post', 'put', 'delete', 'patch'],
            'ui_patterns': ['form', 'table', 'card', 'modal', 'navigation'],
            'data_patterns': ['model', 'schema', 'migration', 'seed']
        }
    
    def _initialize_generation_strategies(self) -> Dict[str, Any]:
        """Initialize code generation strategies"""
        return {
            'web_application': {
                'file_structure': [
                    'src/',
                    'src/components/',
                    'src/pages/', 
                    'src/hooks/',
                    'src/services/',
                    'src/utils/',
                    'src/styles/',
                    'public/',
                    'tests/'
                ],
                'entry_files': ['src/App.js', 'src/index.js', 'public/index.html']
            },
            'api_service': {
                'file_structure': [
                    'routes/',
                    'models/',
                    'schemas/',
                    'services/',
                    'middleware/',
                    'utils/',
                    'tests/',
                    'migrations/'
                ],
                'entry_files': ['main.py', 'app.py', 'server.js']
            },
            'full_stack': {
                'file_structure': [
                    'frontend/',
                    'frontend/src/',
                    'frontend/src/components/',
                    'frontend/public/',
                    'backend/',
                    'backend/routes/',
                    'backend/models/',
                    'shared/',
                    'docs/'
                ],
                'entry_files': [
                    'frontend/src/App.js',
                    'backend/main.py',
                    'docker-compose.yml'
                ]
            }
        }
    
    async def generate_implementation(
        self,
        plan: ImplementationPlan,
        features: List[FeatureRequirement],
        output_path: Optional[Path] = None
    ) -> GenerationResult:
        """
        Generate complete implementation from plan and requirements
        """
        start_time = datetime.now()
        logger.info(f"Starting code generation for {plan.project_name}")
        
        output_path = output_path or self.project_path
        generated_files = []
        errors = []
        warnings = []
        
        try:
            # Create project structure
            await self._create_project_structure(plan, output_path)
            
            # Generate code for each milestone/task
            for milestone in plan.milestones:
                milestone_files = await self._generate_milestone_code(
                    milestone, features, plan.tech_context, output_path
                )
                generated_files.extend(milestone_files)
            
            # Generate configuration files
            config_files = await self._generate_configuration_files(
                plan, output_path
            )
            generated_files.extend(config_files)
            
            # Generate documentation
            doc_files = await self._generate_documentation(
                plan, features, output_path
            )
            generated_files.extend(doc_files)
            
            # Write all files to disk
            files_written = await self._write_files_to_disk(generated_files, output_path)
            
            # Calculate metrics
            generation_time = (datetime.now() - start_time).total_seconds()
            metrics = self._calculate_metrics(generated_files, generation_time)
            
            logger.info(f"Code generation completed in {generation_time:.2f}s")
            
            return GenerationResult(
                success=True,
                files_created=generated_files,
                files_modified=[],
                errors=errors,
                warnings=warnings,
                metrics=metrics,
                generation_time=generation_time
            )
            
        except Exception as e:
            logger.error(f"Code generation failed: {e}")
            errors.append(str(e))
            
            return GenerationResult(
                success=False,
                files_created=generated_files,
                files_modified=[],
                errors=errors,
                warnings=warnings,
                metrics={},
                generation_time=(datetime.now() - start_time).total_seconds()
            )
    
    async def _create_project_structure(
        self, 
        plan: ImplementationPlan, 
        output_path: Path
    ):
        """Create the basic project directory structure"""
        
        # Determine project structure based on tech context
        if plan.tech_context.project_type == 'web' and 'react' in plan.tech_context.tech_stack:
            strategy = self.generation_strategies['web_application']
        elif plan.tech_context.project_type == 'api':
            strategy = self.generation_strategies['api_service']
        else:
            strategy = self.generation_strategies['full_stack']
        
        # Create directories
        for directory in strategy['file_structure']:
            dir_path = output_path / directory
            dir_path.mkdir(parents=True, exist_ok=True)
            logger.debug(f"Created directory: {dir_path}")
    
    async def _generate_milestone_code(
        self,
        milestone: Milestone,
        features: List[FeatureRequirement],
        tech_context: TechnicalContext,
        output_path: Path
    ) -> List[CodeFile]:
        """Generate code for a specific milestone"""
        
        generated_files = []
        
        for task in milestone.tasks:
            task_files = await self._generate_task_code(
                task, features, tech_context, output_path
            )
            generated_files.extend(task_files)
        
        return generated_files
    
    async def _generate_task_code(
        self,
        task: TaskStep,
        features: List[FeatureRequirement],
        tech_context: TechnicalContext,
        output_path: Path
    ) -> List[CodeFile]:
        """Generate code for a specific task"""
        
        generated_files = []
        
        if task.category == 'setup':
            files = await self._generate_setup_files(task, tech_context)
        elif task.category == 'database':
            files = await self._generate_database_files(task, tech_context, features)
        elif task.category == 'api':
            files = await self._generate_api_files(task, tech_context, features)
        elif task.category == 'ui':
            files = await self._generate_ui_files(task, tech_context, features)
        elif task.category == 'authentication':
            files = await self._generate_auth_files(task, tech_context)
        elif task.category == 'business_logic':
            files = await self._generate_business_logic_files(task, tech_context, features)
        elif task.category == 'testing':
            files = await self._generate_test_files(task, tech_context, features)
        else:
            # Generic file generation
            files = await self._generate_generic_files(task, tech_context)
        
        generated_files.extend(files)
        return generated_files
    
    async def _generate_setup_files(
        self, 
        task: TaskStep, 
        tech_context: TechnicalContext
    ) -> List[CodeFile]:
        """Generate project setup files"""
        
        files = []
        
        if 'python' in tech_context.tech_stack:
            # Generate requirements.txt
            files.append(CodeFile(
                path="requirements.txt",
                content=self.templates['python']['requirements_txt'],
                language="text",
                file_type="config",
                dependencies=[],
                imports=[],
                exports=[],
                metadata={"task_id": task.id, "category": task.category}
            ))
            
            # Generate main.py for FastAPI
            if tech_context.framework == 'fastapi':
                main_content = self.templates['python']['fastapi_main'].format(
                    description=f"FastAPI application for {tech_context.project_type}",
                    project_name=tech_context.project_type.title() + " API",
                    route_imports="",  # Will be filled later
                    router_includes="",  # Will be filled later
                    timestamp=datetime.now().isoformat()
                )
                
                files.append(CodeFile(
                    path="main.py",
                    content=main_content,
                    language="python",
                    file_type="implementation",
                    dependencies=["fastapi", "uvicorn"],
                    imports=["fastapi", "sqlalchemy"],
                    exports=["app"],
                    metadata={"task_id": task.id, "entry_point": True}
                ))
        
        elif 'javascript' in tech_context.tech_stack:
            # Generate package.json
            if tech_context.project_type == 'web' and 'react' in tech_context.tech_stack:
                package_content = self.templates['react']['package_json'].format(
                    project_name_lower=tech_context.project_type.lower().replace(' ', '-'),
                    description=f"React application for {tech_context.project_type}"
                )
            else:
                package_content = self.templates['javascript']['package_json'].format(
                    project_name_lower=tech_context.project_type.lower().replace(' ', '-'),
                    description=f"Node.js application for {tech_context.project_type}"
                )
            
            files.append(CodeFile(
                path="package.json",
                content=package_content,
                language="json",
                file_type="config",
                dependencies=[],
                imports=[],
                exports=[],
                metadata={"task_id": task.id, "category": task.category}
            ))
        
        return files
    
    async def _generate_database_files(
        self, 
        task: TaskStep, 
        tech_context: TechnicalContext,
        features: List[FeatureRequirement]
    ) -> List[CodeFile]:
        """Generate database-related files"""
        
        files = []
        
        if 'python' in tech_context.tech_stack:
            # Generate database configuration
            files.append(CodeFile(
                path="database.py",
                content=self.templates['python']['database_config'],
                language="python",
                file_type="implementation",
                dependencies=["sqlalchemy"],
                imports=["sqlalchemy"],
                exports=["engine", "SessionLocal", "get_db"],
                metadata={"task_id": task.id, "category": "database"}
            ))
            
            # Generate models based on features
            db_features = [f for f in features if f.category == 'database' or 'database' in f.technical_specs]
            
            for feature in db_features:
                model_file = await self._generate_model_from_feature(feature, tech_context)
                if model_file:
                    files.append(model_file)
        
        return files
    
    async def _generate_model_from_feature(
        self, 
        feature: FeatureRequirement, 
        tech_context: TechnicalContext
    ) -> Optional[CodeFile]:
        """Generate a database model from a feature requirement"""
        
        if 'python' not in tech_context.tech_stack:
            return None
        
        # Extract entity information
        entity_name = self._extract_entity_name(feature)
        if not entity_name:
            return None
        
        # Generate fields based on feature description
        fields = self._infer_model_fields(feature)
        
        model_content = self.templates['python']['sqlalchemy_model'].format(
            description=f"Database model for {entity_name}",
            entity_name=entity_name,
            model_name=entity_name.title(),
            table_name=entity_name.lower() + 's',
            fields=fields,
            to_dict_fields=self._generate_to_dict_fields(fields)
        )
        
        return CodeFile(
            path=f"models/{entity_name.lower()}.py",
            content=model_content,
            language="python",
            file_type="implementation",
            dependencies=["sqlalchemy"],
            imports=["sqlalchemy", "datetime"],
            exports=[entity_name.title()],
            metadata={"entity": entity_name, "feature_id": feature.name}
        )
    
    async def _generate_api_files(
        self, 
        task: TaskStep, 
        tech_context: TechnicalContext,
        features: List[FeatureRequirement]
    ) -> List[CodeFile]:
        """Generate API-related files"""
        
        files = []
        
        # Find API-related features
        api_features = [f for f in features if f.category == 'api' or 'api' in f.technical_specs]
        
        for feature in api_features:
            if 'python' in tech_context.tech_stack and tech_context.framework == 'fastapi':
                # Generate FastAPI router
                router_file = await self._generate_fastapi_router(feature, tech_context)
                if router_file:
                    files.append(router_file)
                
                # Generate Pydantic schemas
                schema_file = await self._generate_pydantic_schema(feature, tech_context)
                if schema_file:
                    files.append(schema_file)
            
            elif 'javascript' in tech_context.tech_stack:
                # Generate Express router
                router_file = await self._generate_express_router(feature, tech_context)
                if router_file:
                    files.append(router_file)
        
        return files
    
    async def _generate_fastapi_router(
        self, 
        feature: FeatureRequirement, 
        tech_context: TechnicalContext
    ) -> Optional[CodeFile]:
        """Generate FastAPI router from feature"""
        
        entity_name = self._extract_entity_name(feature)
        if not entity_name:
            return None
        
        router_content = self.templates['python']['fastapi_router'].format(
            description=f"API routes for {entity_name}",
            entity_name=entity_name,
            model_file=entity_name.lower(),
            model_name=entity_name.title(),
            schema_file=entity_name.lower(),
            schema_name=entity_name.title(),
            endpoint_prefix=entity_name.lower() + 's',
            tag_name=entity_name.lower()
        )
        
        return CodeFile(
            path=f"routes/{entity_name.lower()}.py",
            content=router_content,
            language="python",
            file_type="implementation",
            dependencies=["fastapi", "sqlalchemy"],
            imports=["fastapi", "sqlalchemy", "typing"],
            exports=["router"],
            metadata={"entity": entity_name, "feature_id": feature.name}
        )
    
    async def _generate_pydantic_schema(
        self, 
        feature: FeatureRequirement, 
        tech_context: TechnicalContext
    ) -> Optional[CodeFile]:
        """Generate Pydantic schema from feature"""
        
        entity_name = self._extract_entity_name(feature)
        if not entity_name:
            return None
        
        # Infer schema fields
        base_fields, update_fields = self._infer_schema_fields(feature)
        
        schema_content = self.templates['python']['pydantic_schema'].format(
            description=f"Pydantic schemas for {entity_name}",
            entity_name=entity_name,
            schema_name=entity_name.title(),
            base_fields=base_fields,
            update_fields=update_fields
        )
        
        return CodeFile(
            path=f"schemas/{entity_name.lower()}.py",
            content=schema_content,
            language="python",
            file_type="implementation",
            dependencies=["pydantic"],
            imports=["pydantic", "datetime", "typing"],
            exports=[f"{entity_name.title()}Create", f"{entity_name.title()}Update", f"{entity_name.title()}Response"],
            metadata={"entity": entity_name, "feature_id": feature.name}
        )
    
    async def _generate_ui_files(
        self, 
        task: TaskStep, 
        tech_context: TechnicalContext,
        features: List[FeatureRequirement]
    ) -> List[CodeFile]:
        """Generate UI-related files"""
        
        files = []
        
        if 'react' in tech_context.tech_stack:
            # Generate React components
            ui_features = [f for f in features if f.category == 'ui']
            
            for feature in ui_features:
                component_file = await self._generate_react_component(feature, tech_context)
                if component_file:
                    files.append(component_file)
            
            # Generate main App component if it doesn't exist
            app_file = await self._generate_react_app(features, tech_context)
            if app_file:
                files.append(app_file)
        
        return files
    
    async def _generate_react_component(
        self, 
        feature: FeatureRequirement, 
        tech_context: TechnicalContext
    ) -> Optional[CodeFile]:
        """Generate React component from UI feature"""
        
        component_name = self._extract_component_name(feature)
        if not component_name:
            return None
        
        # Determine component type and generate appropriate content
        jsx_content = self._generate_jsx_content(feature)
        props = self._infer_component_props(feature)
        state_definitions = self._generate_state_definitions(feature)
        event_handlers = self._generate_event_handlers(feature)
        
        component_content = self.templates['react']['component_template'].format(
            description=f"React component for {component_name}",
            component_name=component_name,
            component_name_lower=component_name.lower(),
            additional_hooks=self._determine_additional_hooks(feature),
            imports=self._generate_react_imports(feature),
            props=props,
            state_definitions=state_definitions,
            event_handlers=event_handlers,
            jsx_content=jsx_content
        )
        
        return CodeFile(
            path=f"src/components/{component_name}.jsx",
            content=component_content,
            language="javascript",
            file_type="implementation",
            dependencies=["react"],
            imports=["react"],
            exports=[component_name],
            metadata={"component_type": "react", "feature_id": feature.name}
        )
    
    async def _generate_test_files(
        self, 
        task: TaskStep, 
        tech_context: TechnicalContext,
        features: List[FeatureRequirement]
    ) -> List[CodeFile]:
        """Generate test files"""
        
        files = []
        
        if 'python' in tech_context.tech_stack:
            # Generate pytest tests
            test_content = self._generate_python_tests(task, features, tech_context)
            
            files.append(CodeFile(
                path=f"tests/test_{task.name.lower().replace(' ', '_')}.py",
                content=test_content,
                language="python",
                file_type="test",
                dependencies=["pytest"],
                imports=["pytest"],
                exports=[],
                metadata={"task_id": task.id, "test_type": "unit"}
            ))
        
        elif 'javascript' in tech_context.tech_stack:
            # Generate Jest tests
            test_content = self._generate_javascript_tests(task, features, tech_context)
            
            files.append(CodeFile(
                path=f"tests/{task.name.lower().replace(' ', '_')}.test.js",
                content=test_content,
                language="javascript",
                file_type="test",
                dependencies=["jest"],
                imports=["jest"],
                exports=[],
                metadata={"task_id": task.id, "test_type": "unit"}
            ))
        
        return files
    
    async def _generate_configuration_files(
        self, 
        plan: ImplementationPlan, 
        output_path: Path
    ) -> List[CodeFile]:
        """Generate configuration files"""
        
        files = []
        
        # Generate .env.example
        env_content = self._generate_env_example(plan.tech_context)
        files.append(CodeFile(
            path=".env.example",
            content=env_content,
            language="text",
            file_type="config",
            dependencies=[],
            imports=[],
            exports=[],
            metadata={"type": "environment"}
        ))
        
        # Generate Docker files if needed
        if plan.tech_context.deployment_target in ['docker', 'kubernetes']:
            dockerfile_content = self._generate_dockerfile(plan.tech_context)
            files.append(CodeFile(
                path="Dockerfile",
                content=dockerfile_content,
                language="dockerfile",
                file_type="config",
                dependencies=[],
                imports=[],
                exports=[],
                metadata={"type": "deployment"}
            ))
        
        return files
    
    async def _generate_documentation(
        self, 
        plan: ImplementationPlan, 
        features: List[FeatureRequirement],
        output_path: Path
    ) -> List[CodeFile]:
        """Generate documentation files"""
        
        files = []
        
        # Generate README.md
        readme_content = self._generate_readme(plan, features)
        files.append(CodeFile(
            path="README.md",
            content=readme_content,
            language="markdown",
            file_type="documentation",
            dependencies=[],
            imports=[],
            exports=[],
            metadata={"type": "project_readme"}
        ))
        
        # Generate API documentation if it's an API project
        if plan.tech_context.project_type == 'api':
            api_docs_content = self._generate_api_documentation(features, plan.tech_context)
            files.append(CodeFile(
                path="docs/api.md",
                content=api_docs_content,
                language="markdown",
                file_type="documentation",
                dependencies=[],
                imports=[],
                exports=[],
                metadata={"type": "api_docs"}
            ))
        
        return files
    
    async def _write_files_to_disk(
        self, 
        files: List[CodeFile], 
        output_path: Path
    ) -> List[str]:
        """Write generated files to disk"""
        
        written_files = []
        
        for file in files:
            file_path = output_path / file.path
            file_path.parent.mkdir(parents=True, exist_ok=True)
            
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(file.content)
                
                written_files.append(str(file_path))
                logger.debug(f"Written file: {file_path}")
                
            except Exception as e:
                logger.error(f"Failed to write file {file_path}: {e}")
        
        return written_files
    
    def _calculate_metrics(
        self, 
        files: List[CodeFile], 
        generation_time: float
    ) -> Dict[str, Any]:
        """Calculate generation metrics"""
        
        total_lines = sum(len(f.content.splitlines()) for f in files)
        
        file_types = {}
        languages = {}
        
        for file in files:
            file_types[file.file_type] = file_types.get(file.file_type, 0) + 1
            languages[file.language] = languages.get(file.language, 0) + 1
        
        return {
            'total_files': len(files),
            'total_lines': total_lines,
            'generation_time_seconds': generation_time,
            'lines_per_second': total_lines / generation_time if generation_time > 0 else 0,
            'file_types': file_types,
            'languages': languages,
            'average_file_size': total_lines / len(files) if files else 0
        }
    
    # Helper methods for code generation
    def _extract_entity_name(self, feature: FeatureRequirement) -> Optional[str]:
        """Extract entity name from feature description"""
        
        # Look for common entity patterns
        description_lower = feature.description.lower()
        
        # Try to extract from feature name first
        name_words = feature.name.split()
        for word in name_words:
            if word.lower() not in ['create', 'add', 'implement', 'build', 'make', 'api', 'crud']:
                return word.lower()
        
        # Try to extract from description
        entity_patterns = [
            r'\b(user|customer|product|order|item|post|comment|article|category)s?\b',
            r'\b(person|member|admin|account|profile|message|notification)s?\b'
        ]
        
        for pattern in entity_patterns:
            match = re.search(pattern, description_lower)
            if match:
                return match.group(1)
        
        return None
    
    def _infer_model_fields(self, feature: FeatureRequirement) -> str:
        """Infer database model fields from feature description"""
        
        fields = []
        description_lower = feature.description.lower()
        
        # Common field patterns
        if 'name' in description_lower:
            fields.append('name = Column(String(100), nullable=False)')
        
        if 'email' in description_lower:
            fields.append('email = Column(String(255), unique=True, nullable=False)')
        
        if 'password' in description_lower:
            fields.append('password_hash = Column(String(255), nullable=False)')
        
        if 'description' in description_lower or 'content' in description_lower:
            fields.append('description = Column(Text)')
        
        if 'price' in description_lower or 'amount' in description_lower:
            fields.append('price = Column(Integer)  # Store in cents')
        
        if 'status' in description_lower:
            fields.append('status = Column(String(50), default="active")')
        
        # If no fields inferred, add a default
        if not fields:
            fields.append('title = Column(String(200), nullable=False)')
            fields.append('description = Column(Text)')
        
        return '\n    '.join(fields)
    
    def _generate_to_dict_fields(self, fields: str) -> str:
        """Generate to_dict fields from model fields"""
        
        field_names = []
        for line in fields.split('\n'):
            if '=' in line:
                field_name = line.strip().split('=')[0].strip()
                field_names.append(f'"{field_name}": self.{field_name}')
        
        return ',\n            '.join(field_names)
    
    def _infer_schema_fields(self, feature: FeatureRequirement) -> Tuple[str, str]:
        """Infer Pydantic schema fields"""
        
        base_fields = []
        description_lower = feature.description.lower()
        
        if 'name' in description_lower:
            base_fields.append('name: str = Field(..., min_length=1, max_length=100)')
        
        if 'email' in description_lower:
            base_fields.append('email: str = Field(..., regex=r"^[^@]+@[^@]+\.[^@]+$")')
        
        if 'description' in description_lower:
            base_fields.append('description: Optional[str] = None')
        
        if 'price' in description_lower:
            base_fields.append('price: int = Field(..., ge=0)  # Price in cents')
        
        # Default fields if none inferred
        if not base_fields:
            base_fields.append('title: str = Field(..., min_length=1)')
            base_fields.append('description: Optional[str] = None')
        
        # For update schema, make fields optional
        update_fields = []
        for field in base_fields:
            if 'Optional' not in field:
                field_name = field.split(':')[0]
                field_type = field.split(':')[1].split('=')[0].strip()
                update_fields.append(f'{field_name}: Optional[{field_type}] = None')
            else:
                update_fields.append(field)
        
        return '\n    '.join(base_fields), '\n    '.join(update_fields)
    
    def _extract_component_name(self, feature: FeatureRequirement) -> Optional[str]:
        """Extract React component name from UI feature"""
        
        # Clean up feature name to make it a valid component name
        name = feature.name.replace(' ', '').replace('_', '').replace('-', '')
        
        # Ensure first letter is uppercase
        if name:
            return name[0].upper() + name[1:]
        
        return None
    
    def _generate_jsx_content(self, feature: FeatureRequirement) -> str:
        """Generate JSX content based on feature type"""
        
        description_lower = feature.description.lower()
        
        if 'form' in description_lower:
            return '''<form onSubmit={handleSubmit} className="form">
                <div className="form-group">
                    <label htmlFor="title">Title</label>
                    <input
                        type="text"
                        id="title"
                        value={formData.title}
                        onChange={(e) => setFormData({...formData, title: e.target.value})}
                        required
                    />
                </div>
                <button type="submit" className="btn btn-primary">
                    Submit
                </button>
            </form>'''
        
        elif 'table' in description_lower or 'list' in description_lower:
            return '''<div className="table-container">
                <table className="data-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Title</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {data.map(item => (
                            <tr key={item.id}>
                                <td>{item.id}</td>
                                <td>{item.title}</td>
                                <td>
                                    <button onClick={() => handleEdit(item.id)}>
                                        Edit
                                    </button>
                                    <button onClick={() => handleDelete(item.id)}>
                                        Delete
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>'''
        
        else:
            return '''<div className="content">
                <h2>{title}</h2>
                <p>{description}</p>
                <button onClick={handleAction} className="btn btn-primary">
                    Action
                </button>
            </div>'''
    
    def _infer_component_props(self, feature: FeatureRequirement) -> str:
        """Infer React component props"""
        
        description_lower = feature.description.lower()
        props = []
        
        if 'data' in description_lower or 'items' in description_lower:
            props.append('data = []')
        
        if 'loading' in description_lower:
            props.append('loading = false')
        
        if 'title' in description_lower:
            props.append('title = ""')
        
        if 'onSubmit' in description_lower or 'form' in description_lower:
            props.append('onSubmit')
        
        return ', '.join(props) if props else ''
    
    def _generate_state_definitions(self, feature: FeatureRequirement) -> str:
        """Generate React state definitions"""
        
        description_lower = feature.description.lower()
        states = []
        
        if 'form' in description_lower:
            states.append('const [formData, setFormData] = useState({});')
        
        if 'loading' in description_lower:
            states.append('const [loading, setLoading] = useState(false);')
        
        if 'error' in description_lower:
            states.append('const [error, setError] = useState(null);')
        
        return '\n    '.join(states) if states else '// State definitions here'
    
    def _generate_event_handlers(self, feature: FeatureRequirement) -> str:
        """Generate React event handlers"""
        
        description_lower = feature.description.lower()
        handlers = []
        
        if 'form' in description_lower:
            handlers.append('''const handleSubmit = (e) => {
        e.preventDefault();
        // Handle form submission
        if (onSubmit) {
            onSubmit(formData);
        }
    };''')
        
        if 'click' in description_lower or 'button' in description_lower:
            handlers.append('''const handleAction = () => {
        // Handle button action
        setLoading(true);
        // Perform action
        setLoading(false);
    };''')
        
        return '\n\n    '.join(handlers) if handlers else '// Event handlers here'
    
    def _determine_additional_hooks(self, feature: FeatureRequirement) -> str:
        """Determine additional React hooks needed"""
        
        description_lower = feature.description.lower()
        hooks = []
        
        if 'api' in description_lower or 'fetch' in description_lower:
            hooks.append(', useEffect')
        
        if 'callback' in description_lower:
            hooks.append(', useCallback')
        
        if 'memo' in description_lower:
            hooks.append(', useMemo')
        
        return ''.join(hooks)
    
    def _generate_react_imports(self, feature: FeatureRequirement) -> str:
        """Generate React component imports"""
        
        imports = []
        description_lower = feature.description.lower()
        
        if 'router' in description_lower or 'navigation' in description_lower:
            imports.append("import { useNavigate } from 'react-router-dom';")
        
        if 'query' in description_lower or 'api' in description_lower:
            imports.append("import { useQuery } from '@tanstack/react-query';")
        
        if 'toast' in description_lower or 'notification' in description_lower:
            imports.append("import toast from 'react-hot-toast';")
        
        return '\n'.join(imports)
    
    def _generate_python_tests(
        self, 
        task: TaskStep, 
        features: List[FeatureRequirement], 
        tech_context: TechnicalContext
    ) -> str:
        """Generate Python test content"""
        
        return f'''"""
Test suite for {task.name}
Generated by ABOV3 Genesis NL2Code Module
"""

import pytest
from unittest.mock import Mock, patch

class Test{task.name.title().replace(' ', '')}:
    """Test class for {task.name}"""
    
    def test_{task.name.lower().replace(' ', '_')}_basic(self):
        """Basic test for {task.name}"""
        # Arrange
        # Act 
        # Assert
        assert True  # Replace with actual test
    
    def test_{task.name.lower().replace(' ', '_')}_error_handling(self):
        """Test error handling for {task.name}"""
        # Arrange
        # Act
        # Assert
        assert True  # Replace with actual test
    
    @pytest.mark.asyncio
    async def test_{task.name.lower().replace(' ', '_')}_async(self):
        """Async test for {task.name}"""
        # Arrange
        # Act
        # Assert
        assert True  # Replace with actual test
'''
    
    def _generate_javascript_tests(
        self, 
        task: TaskStep, 
        features: List[FeatureRequirement], 
        tech_context: TechnicalContext
    ) -> str:
        """Generate JavaScript test content"""
        
        return f'''/**
 * Test suite for {task.name}
 * Generated by ABOV3 Genesis NL2Code Module
 */

describe('{task.name}', () => {{
    beforeEach(() => {{
        // Setup before each test
    }});
    
    afterEach(() => {{
        // Cleanup after each test
    }});
    
    test('should handle basic functionality', () => {{
        // Arrange
        // Act
        // Assert
        expect(true).toBe(true); // Replace with actual test
    }});
    
    test('should handle error cases', () => {{
        // Arrange
        // Act
        // Assert
        expect(true).toBe(true); // Replace with actual test
    }});
    
    test('should handle async operations', async () => {{
        // Arrange
        // Act
        // Assert
        expect(true).toBe(true); // Replace with actual test
    }});
}});
'''
    
    def _generate_env_example(self, tech_context: TechnicalContext) -> str:
        """Generate .env.example file"""
        
        env_vars = [
            "# Environment Configuration",
            "NODE_ENV=development",
            "",
            "# Database",
            "DATABASE_URL=sqlite:///./app.db",
            "",
            "# API Configuration", 
            "API_PORT=3000",
            "API_HOST=localhost",
            "",
            "# Authentication",
            "JWT_SECRET=your-secret-key-here",
            "JWT_EXPIRES_IN=7d",
            ""
        ]
        
        if tech_context.database == 'postgresql':
            env_vars.extend([
                "# PostgreSQL specific",
                "POSTGRES_HOST=localhost", 
                "POSTGRES_PORT=5432",
                "POSTGRES_DB=myapp",
                "POSTGRES_USER=postgres",
                "POSTGRES_PASSWORD=password",
                ""
            ])
        
        return '\n'.join(env_vars)
    
    def _generate_dockerfile(self, tech_context: TechnicalContext) -> str:
        """Generate Dockerfile"""
        
        if 'python' in tech_context.tech_stack:
            return '''FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    gcc \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN adduser --disabled-password --gecos '' --uid 1000 appuser
RUN chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:8000/health || exit 1

# Start the application
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
'''
        else:
            return '''FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy application code
COPY . .

# Create non-root user
RUN addgroup -g 1001 -S appgroup
RUN adduser -S appuser -u 1001 -G appgroup
RUN chown -R appuser:appgroup /app
USER appuser

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:3000/health || exit 1

# Start the application
CMD ["npm", "start"]
'''
    
    def _generate_readme(
        self, 
        plan: ImplementationPlan, 
        features: List[FeatureRequirement]
    ) -> str:
        """Generate README.md content"""
        
        feature_list = '\n'.join(f"- {f.name}: {f.description}" for f in features[:10])
        if len(features) > 10:
            feature_list += f"\n- And {len(features) - 10} more features..."
        
        tech_stack = ', '.join(plan.tech_context.tech_stack)
        
        return f'''# {plan.project_name}

{plan.description}

## Features

{feature_list}

## Technology Stack

- **Framework**: {plan.tech_context.framework}
- **Technologies**: {tech_stack}
- **Database**: {plan.tech_context.database}
- **Deployment**: {plan.tech_context.deployment_target}

## Quick Start

1. Clone the repository
2. Install dependencies:
   ```bash
   # For Python projects
   pip install -r requirements.txt
   
   # For Node.js projects
   npm install
   ```

3. Set up environment variables:
   ```bash
   cp .env.example .env
   # Edit .env with your configuration
   ```

4. Run the application:
   ```bash
   # For Python/FastAPI projects
   uvicorn main:app --reload
   
   # For Node.js projects
   npm start
   
   # For React projects
   npm start
   ```

## Project Structure

Generated using ABOV3 Genesis NL2Code Module with the following milestones:

{self._format_milestones_for_readme(plan.milestones)}

## Development

### Running Tests

```bash
# Python projects
pytest

# Node.js projects  
npm test
```

### Code Quality

```bash
# Python projects
black .
isort .
flake8 .

# Node.js projects
npm run lint
npm run lint:fix
```

## Deployment

This project is configured for deployment to {plan.tech_context.deployment_target}.

See deployment documentation in `docs/deployment.md` for detailed instructions.

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Submit a pull request

## License

MIT License - see LICENSE file for details.

---

*Generated by ABOV3 Genesis NL2Code Module*
*Total estimated development time: {plan.total_estimated_hours} hours*
*Completion date: {plan.estimated_completion_date.strftime('%Y-%m-%d')}*
'''
    
    def _format_milestones_for_readme(self, milestones: List[Milestone]) -> str:
        """Format milestones for README"""
        
        milestone_text = []
        for i, milestone in enumerate(milestones, 1):
            milestone_text.append(f"{i}. **{milestone.name}**: {milestone.description}")
        
        return '\n'.join(milestone_text)
    
    def _generate_api_documentation(
        self, 
        features: List[FeatureRequirement], 
        tech_context: TechnicalContext
    ) -> str:
        """Generate API documentation"""
        
        api_features = [f for f in features if f.category == 'api']
        
        endpoints_doc = []
        for feature in api_features:
            entity_name = self._extract_entity_name(feature)
            if entity_name:
                endpoints_doc.append(f"""
### {entity_name.title()} Endpoints

- `GET /{entity_name.lower()}s` - Get all {entity_name}s
- `GET /{entity_name.lower()}s/{{id}}` - Get {entity_name} by ID
- `POST /{entity_name.lower()}s` - Create new {entity_name}
- `PUT /{entity_name.lower()}s/{{id}}` - Update {entity_name}
- `DELETE /{entity_name.lower()}s/{{id}}` - Delete {entity_name}
""")
        
        return f'''# API Documentation

This document describes the REST API endpoints for the {tech_context.project_type} application.

## Base URL

```
http://localhost:8000  # Development
```

## Authentication

{self._generate_auth_docs(features)}

## Endpoints

{''.join(endpoints_doc)}

## Error Responses

All endpoints return consistent error responses:

```json
{{
    "error": "Error message",
    "detail": "Detailed error information",
    "status_code": 400
}}
```

## Status Codes

- `200` - Success
- `201` - Created
- `400` - Bad Request
- `401` - Unauthorized
- `403` - Forbidden
- `404` - Not Found
- `500` - Internal Server Error

---

*Generated by ABOV3 Genesis NL2Code Module*
'''
    
    def _generate_auth_docs(self, features: List[FeatureRequirement]) -> str:
        """Generate authentication documentation"""
        
        auth_features = [f for f in features if f.category == 'authentication']
        
        if auth_features:
            return """
Authentication is required for protected endpoints. Include the JWT token in the Authorization header:

```
Authorization: Bearer <your-token>
```

### Auth Endpoints

- `POST /auth/register` - Register new user
- `POST /auth/login` - Login user
- `POST /auth/logout` - Logout user
- `POST /auth/refresh` - Refresh token
"""
        else:
            return "No authentication required for this API."
    
    async def _generate_generic_files(
        self, 
        task: TaskStep, 
        tech_context: TechnicalContext
    ) -> List[CodeFile]:
        """Generate generic files for unhandled task categories"""
        
        files = []
        
        # Create a placeholder file
        placeholder_content = f'''"""
{task.description}
Generated by ABOV3 Genesis NL2Code Module

Task ID: {task.id}
Category: {task.category}
Estimated Hours: {task.estimated_hours}
"""

# TODO: Implement {task.name}
# Description: {task.description}

def main():
    """Main function for {task.name}"""
    print("TODO: Implement {task.name}")

if __name__ == "__main__":
    main()
'''
        
        files.append(CodeFile(
            path=f"src/{task.name.lower().replace(' ', '_')}.py",
            content=placeholder_content,
            language="python",
            file_type="implementation", 
            dependencies=[],
            imports=[],
            exports=["main"],
            metadata={"task_id": task.id, "category": task.category}
        ))
        
        return files
    
    async def _generate_auth_files(
        self, 
        task: TaskStep, 
        tech_context: TechnicalContext
    ) -> List[CodeFile]:
        """Generate authentication-related files"""
        
        files = []
        
        if 'python' in tech_context.tech_stack:
            # Generate auth utilities
            auth_content = '''"""
Authentication utilities
"""

from passlib.context import CryptContext
from datetime import datetime, timedelta
from jose import JWTError, jwt
from fastapi import HTTPException, status
import os

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

SECRET_KEY = os.getenv("JWT_SECRET", "dev-secret-key")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

def verify_password(plain_password, hashed_password):
    """Verify password"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    """Hash password"""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: timedelta = None):
    """Create access token"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str):
    """Verify token"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate credentials"
            )
        return username
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials"
        )
'''
            
            files.append(CodeFile(
                path="auth/utils.py",
                content=auth_content,
                language="python",
                file_type="implementation",
                dependencies=["passlib", "python-jose", "fastapi"],
                imports=["passlib", "jose", "fastapi"],
                exports=["verify_password", "get_password_hash", "create_access_token", "verify_token"],
                metadata={"task_id": task.id, "category": "authentication"}
            ))
        
        return files